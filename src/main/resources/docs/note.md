[TOC]

## 父子递归调用
场景: 文本解析生成节点树  
关键点: 边界  
父子类功能不同
* 父类 
    1. 边界 下放控制权给子类  
    对于开始边界,子类处理完就结束了  
    对于结束边界,控制权是由子类给父类的,父类再把控制权交给子类处理的  
    所以子类处理完后要返还给父类,父类再返还给子类,子类再返回父类,就处理完毕了
    2. 非边界 自己处理
* 子类 
    1. 接收开始边界
    2. 把递归开始边界交给父类
    3. 处理结束边界 再返还控制权给父类
    4. 非边界交给父类处理
    
综上所述:
> 总控制权在父类, 负责在遇到边界时下发控制权, 也能处理非边界;  
> 子类负责内部处理, 主要是处理结束边界, 而遇到非结束边界时 需要再把控制权交还父类
> 控制权要父子类之间流转 形成递归
>
### 边界
1. 父类遇到`开始边界`时 要生成子类(`new Sub()`),并把控制权下放(`sub.parse`)给子类, 子类处理完后`break and next`
2. 子类遇到`非结束结界`时  要把控制权交(`super.parse`)给父类, 再`return`
3. 父类遇到`结束边界`时 要把控制权交(`this.parse`)给子类来处理, 再`return`
4. 子类遇到`结束边界`时 处理完后再`return`
5. 权力是别人给的 所以`return`是为了返还控制权
6. 父类遇到`非边界`时 一般直接处理
7. 子类`具有状态` 记忆开始边界,才能处理结束边界,还能处理嵌套开始边界  
8. 父类`没有状态` 只是负责控制权的转移
9. 特殊情况,父类也会有状态,如:父类无法判断边界是开始边界还是结束边界时

### 通用递归
父子类都要实现parse方法
```java
public boolean parse(Lexer lexer) {
    Token token;
    while (lexer.hasNext()) {
        log.debug("token: {}", token);
        switch (token.getType()) {
            // 边界或非边界处理
        }
    }
}
```


### 回溯
暂无

## 人生箴言
说100遍,不如写一遍  
写100遍,不如仔细思考、分析、归纳、总结、记忆  
明白事物的内在逻辑规律,才能一器破万法  